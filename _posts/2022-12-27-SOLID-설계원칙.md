---
layout: post
title: "SOLID 설계원칙"
date: 2022-12-27
category: "ProgrammingMethodology"
---

{% raw %}
# SOLID 설계원칙

> 객체지향적으로 설계하는데 기본이 되는 SOLID 설계원칙

* * *

1. 단일 책임 원칙(Single responsibility principle; SRP)
2. 개방-폐쇄 원칙(Open-closed principle: OCP)
3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
4. 인터페이스 분리 원칙(Interface segregation principle; ISP)
5. 의존 역전 원칙(Dependency inversion principle; DIP)

* * *

## 1. 단일 책임 원칙(Single responsibility principle; SRP)

단일 책임 원칙(Single responsibility principle; SRP)은 "클래스는 단 한 개의 책임을 가져야 한다"는 원칙이다. 클래스가 여러 책임을 갖게 될 수록 각 책임마다 클래스의 변경이 발생하기 때문이다.

## 2. 개방-폐쇄 원칙(Open-closed principle: OCP)

개방-폐쇄 원칙(Open-closed principle: OCP)은 "확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다"는 원칙이다.

`나무 도구 세트(WoodenToolSet)`를 사용하는 `수리공(RepairMan)`이 있다.

```java
@Setter
class RepairMan {
    WoodenToolSet woodenToolSet;

    public void repairWithASetOfWoodenTools() {
        // ...
    }

}
```

어느날 `수리공(RepairMan)`의 서비스에 큰 감동을 받은 한 고객이 수리공에게 `강철 도구 세트(SteelToolSet)`를 선물했다. 현재 `수리공(RepairMan)`은 `나무 도구 세트(WoodenToolSet)`만을 사용할 수 있기 때문에, `강철 도구 세트(SteelToolSet)`를 사용하기 위해서는 클래스에 `강철 도구 세트(SteelToolSet)`를 추가해주어야 한다.

```java
class WoodenToolSet {
    public void repair() {
        // ...
    }
}

class SteelToolSet {
    public void repair() {
        // ...
    }
}

@Setter
class ReparMan {
    WoodenToolSet woodenToolSet;
    SteelToolSet steelToolSet;

    public void repairWithASetOfWoodenTools() {
        this.woodenToolSet.repair();
    }

    public void repairWithASetOfSteelTools() {
        this.steelToolSet.repair();
    }
}
```

위와 같이 코드를 작성한다면, `수리공(Repairman)`이 갖고있는 도구 세트가 늘어날 때마다, 변수와 메서드를 계속해서 생성해주어야 한다. 그렇다면 이것은 확장과 변경에 모두 열려있는 코드이다. 그렇다면 확장에는 열려있지만 변경에는 닫혀있는 코드란 어떤 것일까?

```java
interface ToolSet() {
    public void repair();
}

class WoodenToolSet implements ToolSet {
    @Override
    public void repair() {
        // ...
    }
}

class SteelToolSet implements ToolSet {
    @Override
    public void repair() {
        // ...
    }
}

@Setter
class RepairMan {
    ToolSet toolSet;

    public void repair() {
        if (toolSet != null) {
            toolSet.repair();
        }
    }
}
```

동일한 동작을 하는 클래스에 동일한 인터페이스를 상속시켜줌으로써, `수리공(Repairman)`은 단지 `도구세트(ToolSet)`만이 적절하게 설정되었다면, `repair()` 메서드를 통해 동일한 동작을 실행할 수 있다.

## 3. 리스코프 치환 원칙(Liskov substitution principle; LSP)

리스코프 치환 원칙(Liskov substitution principle; LSP)은 "상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다"는 원칙이다. 즉, 상위타입의 객체에 하위 타입의 객체를 할당하더라도, 상위 타입의 객체에서 제공하는 메서드에 대해서 하위 타입의 객체가 정상적으로 동작해야한다.

## 4. 인터페이스 분리 원칙(Interface segregation principle; ISP)

인터페이스 분리 원칙(Interface segregation principle; ISP)은 "인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다."는 원칙이다. 각 다른 역할을 담당하는 클래스에서 사용이 가능한 만능 인터페이스가 존재한다고 가정해보자. 그렇다면

## 5. 의존 역전 원칙(Dependency inversion principle; DIP)

의존 역전 원칙(Dependency inversion principle; DIP)은 "고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다."는 원칙이다.

{% endraw %}
