---
layout: post
title: "SOLID 설계원칙"
date: 2022-12-27
category: "ProgrammingMethodology"
---

{% raw %}
# SOLID 설계원칙

> 객체지향적으로 설계하는데 기본이 되는 SOLID 설계원칙

* * *

1. 단일 책임 원칙(Single responsibility principle; SRP)
2. 개방-폐쇄 원칙(Open-closed principle: OCP)
3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
4. 인터페이스 분리 원칙(Interface segregation principle; ISP)
5. 의존 역전 원칙(Dependency inversion principle; DIP)

* * *

## 1. 단일 책임 원칙(Single responsibility principle; SRP)

단일 책임 원칙(Single responsibility principle; SRP)은 "클래스는 단 한 개의 책임을 가져야 한다"는 원칙이다. 클래스가 여러 책임을 갖게 될 수록 각 책임마다 클래스의 변경이 발생하기 때문이다.

### 1.1 주어진 상황

```java
class Human {
}
```

어떤 사람은 평일에는 수리공으로 일을 하고, 주말에는 화공(Painter)으로 일을 한다. 이 사람은 수리할 수 있는 능력과 페인트 칠을 할 수 있는 능력을 갖고 있다.

### 1.2 단일 책임 원칙을 지키지 않은 코드

```java
class Human {
    private ToolSet toolSet;

    public void repairing();
    public void painting();
    public void setToolSet(ToolSet toolSet) {
        this.toolSet = toolSet;
    }
}

class Main {
    public static void main() {
        Human human = new Human();

        if ( WEEKDAY ) {
            human.setToolSet(new RepairToolSet());
            human.repairing();
        } else if ( WEEKEND ) {
            human.setToolSet(new ArtToolSet());
            human.painting();
        }
    }
}
```

어느날 이 사람은 자신이 색을 구분하지 못한다는 사실을 깨닫고, 주말에는 제빵사가 되기로 다짐했다.

```java
class Human {
    private ToolSet toolSet;

    public void repair();
    // painting -> baking
    public void baking();
    public void setToolSet(ToolSet toolSet) {
        this.toolSet = toolSet;
    }
}

class Main {
    public static void main() {
        Human human = new Human();

        if ( WEEKDAY ) {
            human.setToolSet(new RepairToolSet());
            human.repair();
        } else if ( WEEKEND ) {
            // ArtToolSet -> BakingToolSet
            human.setToolSet(new BakingToolSet());
            // painting -> baking
            human.baking();
        }
    }
}
```

위와 같은 요구사항이 발생했을 때, 단일 책임 원칙을 지키지 않았을 때는, `Human` 클래스를 사용하는 곳과 `Human` 클래스의 페인팅 기능과 관련된 모든 부분에서 변경이 발생한다. 다음으로, 단일 책임 원칙을 지키는 코드를 통해 요구사항에 대해 최소한의 변경으로 안정적인 요구사항을 반영할 수 있는 방법을 알아본다. 

### 1.3 단일 책임 원칙을 지키는 코드

```java
interface Human {
    public void work();
}

class RepairMan implements Human {
    private ToolSet toolSet = new RepairToolSet();
    public void work() {
        // repairing
    }
}

class Artist implements Human {
    private ToolSet toolSet = new ArtToolSet();
    public void work() {
        // painting
    }
}

class Main {
    public static void main() {
        Human human;

        if ( WEEKDAY ) {
            human = new RepairMan();
        } else if ( WEEKEND ) {
            human = new Artist();
        }
        human.work();
    }
}
```

마찬가지로, 단일 책임 원칙을 지키지 않았을 때와 동일하게 어느날 이 사람은 자신이 색을 구분하지 못한다는 사실을 깨닫고, 주말에는 제빵사가 되기로 다짐했다.

``` java
interface Human {
    public void work();
}

class RepairMan implements Human {
    private ToolSet toolSet = new RepairToolSet();
    public void work() {
        // repairing
    }
}

class Artist implements Human {
    private ToolSet toolSet = new ArtToolSet();
    public void work() {
        // painting
    }
}

class Baker implements Human {
    private ToolSet toolSet = new BakingToolSet();
    public void work() {
        // baking
    }
}

class Main {
    public static void main() {
        Human human;

        if ( WEEKDAY ) {
            human = new RepairMan();
        } else if ( WEEKEND ) {
            // Artist -> Baker
            human = new Baker();
        }
        human.work();
    }
}
```

단일 책임 원칙을 지킬 경우에는 `Human` 클래스를 사용하는 곳에서 단지 `Artist` 클래스에서 `Baker` 클래스를 할당하는 것 만으로도 쉽게 변화를 발생시킬 수 있다.

이와 같이 단일 책임 원칙을 지키는 것 만으로도 최소한의 변화로 안정적인 코드의 변화를 이룰 수 있다는 장점을 얻을 수 있다. 그렇다면 단일 책임 원칙을 지키고 있는지를 쉽게 알 수 있는 방법은 무엇일까? 가장 쉽게 알 수 있는 방법은 클래스가 사용되는 곳을 확인하는 것이다. 만약 클래스를 사용하는 곳에서 각각 다른 책임의 메서드만을 호출하고 있다면, 해당 클래스는 여러 책임을 갖고 있음을 알 수 있다.

## 2. 개방-폐쇄 원칙(Open-closed principle: OCP)

개방-폐쇄 원칙(Open-closed principle: OCP)은 "확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다"는 원칙이다.

`수리공(Repairman)`이 기존에 `나무 도구 세트(WoodenToolSet)`를 사용하다가, 돈을 많이 벌어서 `강철 도구 세트(SteelToolSet)`를 샀다. 수리공은 단지 도구만을 바꾸었을 뿐이지 망치질하고 자르는 수리공의 행동에는 변화가 없다. 즉, 수리공은 사용할 수 있는 도구의 확장은 열려있고 수리공이 수리하는 행동은 변화 될 필요성이 없다.

```java
interface ToolSet {
    public void hammering();
    public void cutting();
}

class WoodenToolSet implements ToolSet {
    // ...
}

class SteelToolSet implements ToolSet {
    // ...
}

class Repairman {
    ToolSet toolSet;

    public Repairman (ToolSet toolSet) {
        this.toolSet = toolSet;
    }

    public void repair() {
        // ...
        toolSet.hammering();
        toolSet.cutting();
    }
}

class Main {
    public static void main() {
        Repairman repairman = new Repairman(new WoodenToolSet());
        repairman.hammering();
        repairman.cutting();
    }
}
```

`Main` 클래스에서 수리공이 나무 도구 세트를 이용하여 수리를 하던 중, 강철 도구 세트를 이용하여 수리를 해야한다면 단지 수리공에게 아래와 같이 강철 도구 세트를 쥐어주기만 하면 된다.

```java
class Main {
    public static void main() {
        // AManufacturerToolSet -> BManufacturerToolSet
        Repairman repairman = new Repairman(new BManufacturerToolSet());
        repairman.hammering();
        repairman.cutting();
    }
}
```

만약 위의 예시가 개방-폐쇄 원칙을 지키지 않았다면, 단지 수리공의 도구만 바뀌었을 뿐인데도 수리공의 행동(`public void repair()`)까지 모두 바꿔야 하는 문제가 발생했을 것이다.

*개방-폐쇄 원칙을 지키지 않은 `Repairman`의 나무 도구 세트 사용 코드*
```java
class Repairman {
    WoodenToolSet woodenToolSet = new WoodenToolSet();

    public void repair() {
        woodenToolSet.hammering();
        woodenToolSet.cutting();
    }
}
```

*개방-폐쇄 원칙을 지키지 않은 `Repiarman`이 나무 도구 세트에서 강철 도구 세트로 바꾸었을 때*
```java
class Repairman {
    // WoodenToolSet -> SteelToolSet
    SteelToolSet steelToolSet = new SteelToolSet();

    public void repair() {
        // woodenToolSet -> steelToolSet;
        steelToolSet.hammering();
        steelToolSet.cutting();
    }
}
```

## 3. 리스코프 치환 원칙(Liskov substitution principle; LSP)

리스코프 치환 원칙(Liskov substitution principle; LSP)은 "상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다"는 원칙이다.

## 4. 인터페이스 분리 원칙(Interface segregation principle; ISP)

## 5. 의존 역전 원칙(Dependency inversion principle; DIP)

{% endraw %}
