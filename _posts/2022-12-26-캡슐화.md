---
layout: post
title: "캡슐화"
date: 2022-12-26
category: "ProgrammingMethodology"
---

{% raw %}
# 캡슐화

> 객체의 속성과 행위를 하나로 묶고, 실제 구현에 대한 자세한 내용을 은닉하는 방법론

* * *

1. 주어진 상황
2. 캡슐화가 이루어지지 않은 코드
3. 캡슐화가 이루어진 코드
4. 캡슐화를 적용시키기 위해서는
5. 나의 상황

* * *

## 1. 주어진 상황

제목에 'A' 문자가 들어간 문서는 "1_GROUP_CD"로 분류되고 "제 1 도서관"으로 이동시킨다, 제목에 'B' 문자가 들어간 문서는 "2_GROUP_CD"로 분류되고 "제 2 도서관"으로 이동시킨다. 이때 제목에 'A'와 'B'가 모두 들어간 문서는 없다고 가정한다.

```java
@Getter
class Document {
    private String groupCode;
}

public void goToLibrary1();
public void goToLibrary2();

public void anyProcess(Document document) {
    // process
}
```

## 2. 캡슐화가 이루어지지 않은 코드

```java
public void anyProcess(Document document) {
    if (document.getGroupCode().equals("1_GROUP_CD")) {
        goToLibrary1();
    } else if (document.getGroupCode().equals("2_GROUP_CD")) {
        goToLibrary2();
    }
}
```

위와 같은 코드에서 'A' 문자가 들어간 제목의 문서가 앞으로는 "1_GROUP_CD"가 아니라 "A_GROUP_CD"로, "2_GROUP_CD"가 아니라 "B_GROUP_CD"로 변경 해달라는 요청이 들어왔다고 가정해보자.

```java
public void anyProcess(Document document) {
    if (document.getGroupCode().equals("A_GROUP_CD")) {
        goToLibrary1();
    } else if (document.getGroupCode().equals("B_GROUP_CD")) {
        goToLibrary2();
    }
}
```

위와 같이 캡슐화가 이루어지지 않은 코드로 작성한다면, 코드가 데이터 중심으로 동작하기 떄문에 중심이 되는 모든 코드를 하나하나 바꿔줘야 하는 문제가 발생한다. 만약, 수만군데에서 해당 내용의 분류법으로 코드를 작성하였다면 모든 코드를 변경하는데 많은 리소스가 들게 된다. 최악의 상황으로는, 특정 부분을 발견하지 못햇을 때, 이전 코드로 분류되고 있는 곳이 존재할 수 있다.

## 3. 캡슐화가 이루어진 코드

```java
class Document {
    boolean isGroup1() {
        return this.group.equals("1_GROUP_CD");
    }

    boolean isGroup2() {
        return this.group.equals("2_GROUP_CD");
    }
}

public void anyProcess(Document document) {
    if (document.isGroup1) {
        goToLibrary1();
    } else if (document.isGroup2) {
        goToLibrary2();
    }
}
```

캡슐화가 이루어진 코드에서도 마찬가지로 "1_GROUP_CD"가 아니라 "A_GROUP_CD"로, "2_GROUP_CD"가 아니라 "B_GROUP_CD"로 변경 해달라는 요청이 들어왔다고 가정해보자.

```java
class Document {
    boolean isGroup1() {
        return this.group.equals("A_GROUP_CD");
    }

    boolean isGroup2() {
        return this.group.equals("B_GROUP_CD");
    }
}

public void anyProcess(Document document) {
    if (document.isGroup1()) {
        goToLibrary1();
    } else if (document.isGroup2()) {
        goToLibrary2();
    }
}
```

캡슐화가 이루어지지 않은 코드와 달리, 분류법이 쓰이는 부분의 변화는 없고 단지 객체의 내용만이 변경되는 것을 확인할 수 있다. 즉, 분류법을 사용하는 모든 곳을 변경할 필요가 없이 객체를 정의하는 내용만을 변경함으로써 최소한의 변경으로 요구사항을 충족시킬 수 있다.

이처럼 캡슐화를 적용시킨다면 최소한의 변경으로 다양한 요구조건 충족시킬 수 있다는 장점이 있다.

## 4. 캡슐화를 적용시키기 위해서는

이와 같이 코드 작성시에 캡슐화를 적용시키기 위해 TDA(Tell, Don't Ask)법칙과 LoD(Law of Demeter) 법칙이 존재한다.

**TDA(Tell, Don't Ask)**법칙은 데이터를 묻지 말고 기능을 실행 하게끔 하라는 법칙이다.

즉, 캡슐화가 이루어지지 않은 코드의 예시에서는 "이 문서의 그룹코드가 '1_GROUP_CD'가 맞다면"과 같은 로직으로 동작한다. 반면, 캡슐화가 이루어진 코드의 예시에서는 "이 문서가 'GROUP1'이라면"과 같은 로직을 동작한다.

예시가 적절치 않을 수 있기에 다른 방법으로 기술하자면, 캡슐화가 이루어지지 않은 코드에서는 문서의 그룹코드 데이터를 가져와서 문서를 검증한다. 반면, 캡슐화가 이루어진 코드에서는 문서의 데이터를 가져오지 않고, 문서의 메서드만을 이용하여 해당 문서를 검증한다.

**LoD(Law of Demeter)**법칙은(이하 데미테르 법칙) 다음과 같은 규칙들로 구성된다.

- 메서드에서 생성한 객체의 메서드만을 호출하라.
- 파라미터로 받은 객체의 메서드만을 호출하라.
- 필드로 참조하는 객체의 메서드만을 호출하라.

각 규칙들에 대해 예시와 함께 살펴보자면 아래와 같다.

*메서드에서 생성한 객체의 메서드만을 호출하라*
```java
// 규칙을 어긴 코드 : 객체의 메서드뿐만 아니라 메서드의 결과물인 String의 메서드를 호출한다.
public void wrongProcess() {
    Document document = getAnyDocument();
    if (document.getGroupCd().equals("1_GROUP_CD")) {
        // ...
    }
}

// 규칙을 지킨 코드 : 객체의 메서드만을 호출한다.
public void followedRuleProcess(Document document) {
    Document document = getAnyDocument();
    if (document.isGroup1()) {
        // ...
    }
}
```

*파라미터로 받은 객체의 메서드만을 호출하라*
```java
// 규칙을 어긴 코드 : 객체의 메서드뿐만 아니라 메서드의 결과물인 String의 메서드를 호출한다.
public void wrongProcess() {
    Document document = getAnyDocument();
    if (document.getGroupCd().equals("1_GROUP_CD")) {
        // ...
    }
}

// 규칙을 지킨 코드 : 객체의 메서드만을 호출한다.
public void followedRuleProcess(Document document) {
    Document document = getAnyDocument();
    if (document.isGroup1()) {
        // ...
    }
}
```

*필드로 참조하는 객체의 메서드만을 호출하라*
```java
class Library {
    Document documents;

    // 규칙을 어긴 코드 : 객체의 메서드뿐만 아니라 메서드의 결과물인 String의 메서드를 호출한다.
    public void wrongProcess() {
        if (document.getGroupCd().equals("1_GROUP_CD")) {
            // ...
        }
    }

    // 규칙을 지킨 코드 : 객체의 메서드만을 호출한다.
    public void followedRuleProcess() {
        if (document.isGroup1()) {
            // ...
        }
    }
}
```

## 나의 상황

실제 문서를 다루는 프로젝트내에서 분류코드에 따른 로직이 변경되는 문제가 발생하였다. 당시에 공통코드에 따른 내부로직이 사용되는 모든 곳이 복사/붙여넣기로 코드가 작성되어 있었고, 추후 해당 로직을 변경하기 위해서 복사/붙여넣기가 진행된 모든 로직을 변경해야 했다. 하지만, 주석과 같이 조금이라도 변경사항이 있는 곳에서는 문자열 검색으로 찾아지지가 않았다. 결국엔 테스트시에 많은 오류를 만날 수 있었다.

{% endraw %}
